##############################################################################

# import packages

##############################################################################


import numpy as np

import heapq

import matplotlib.pyplot as plt

import serial

import time

from matplotlib.pyplot import figure

from easyEEZYbotARM.kinematic_model import EEZYbotARM_Mk1

##############################################################################

# plot grid

##############################################################################
def dodajOgraniczenia(siatka):
    np.asarray(np.where(siatka) == 1).T # where wyszukuje wszystkie 1 w siatka i zwraca to jako tople,
    searchval = [1, 0] #jakiej kombinacji szukamy
    N = len(searchval)
    possibles = zip(*np.where(siatka == searchval[0])) # where wyszukuje wszystkie 1 w siatka i zwraca to jako tople,
    # natomiast zip zamienia to na list-of-lists https://stackoverflow.com/questions/27175400/how-to-find-the-index-of-a-value-in-2d-array-in-python

    solns = []
    for p in possibles: #przeszukiwanie wszystkich otrzymanych 1 w celu znalezienia kombinacji

        check = grid[p[0], p[1], p[2]:p[2] + N]
        if np.all(check == searchval):
            solns.append(p)
            siatka[p[0]][p[1]][p[2]+N-1] = 1
    return siatka

def dodajOgraniczeniaX(siatka): #ograniczenie w osi x 6 cm za przeszkoda nie moze znaleźć się ramie robota bo zachaczy

    punktOgraniczenia = []
    np.asarray(np.where(siatka) == 1).T  # where wyszukuje wszystkie 1 w siatka i zwraca to jako tople, asarray działa jak zip tylko zwraca np array
    searchval = [1, 0]  # jakiej kombinacji szukamy
    searchval2 = [0, 1] #kombinacja górna
    N = len(searchval)
    possibles = np.vstack(np.where(siatka == searchval[0])).T  # where wyszukuje wszystkie 1 w siatka i zwraca to jako tople,
    a = np.sort([i[0] for i in possibles])
    i = a[-1] + 1
    while i <= len(siatka) - 1 and i <= a[-1] + 6:
        siatka[i] = siatka[a[-1]]
        i+=1
    return siatka


def dodajOgraniczeniaY(siatka):  # ograniczenie w osi x 6 cm za przeszkoda nie moze znaleźć się ramie robota bo zachaczy
    # funkcja zwracająca pozycję 2 skrajnych punktów na górnej tej dalszej od robota krawędzi przeszkody
    punktOgraniczenia = []
    np.asarray(np.where(siatka) == 1).T  # where wyszukuje wszystkie 1 w siatka i zwraca to jako tople, asarray działa jak zip tylko zwraca np array
    searchval = [1, 0]  # jakiej kombinacji szukamy
    searchval2 = [0, 1]  # kombinacja górna
    N = len(searchval)
    possibles = np.vstack(
        np.where(siatka == searchval[0])).T  # where wyszukuje wszystkie 1 w siatka i zwraca to jako tople,

    # sortowanie w celu znalezienia współrzędnej x krawędzi dalszej
    for p in possibles:  # przeszukiwanie wszystkich otrzymanych 1 w celu znalezienia kombinacji
        check2 = siatka[p[0], p[1] - 1:p[1] + 1, p[2]]
        check3 = siatka[p[0], p[1]:p[1] + 2, p[2]]
        if np.all(check2 == searchval2):  # współrzędna x krawędzi dalszej
            siatka[p[0], p[1] - 1, p[2]] = 1  # insert żeby zawsze na początek wrzucał
        elif np.all(check3 == searchval):
            siatka[p[0], p[1] + 1, p[2]] = 1  #
        return siatka

def wyszukajSkrajne(siatka):
    #funkcja zwracająca pozycję 2 skrajnych punktów na górnej tej dalszej od robota krawędzi przeszkody
    punktOgraniczenia = []
    np.asarray(np.where(siatka) == 1).T  # where wyszukuje wszystkie 1 w siatka i zwraca to jako tople, asarray działa jak zip tylko zwraca np array
    searchval = [1, 0]  # jakiej kombinacji szukamy
    searchval2 = [0, 1] #kombinacja górna
    N = len(searchval)
    possibles = np.vstack(
        np.where(siatka == searchval[0])).T  # where wyszukuje wszystkie 1 w siatka i zwraca to jako tople,

    a = np.sort([i[0] for i in possibles])
    # sorted_array = an_array[np.argsort(possibles2[:, 1])]
    # natomiast zip zamienia to na list-of-lists https://stackoverflow.com/questions/27175400/how-to-find-the-index-of-a-value-in-2d-array-in-python
    # sortowanie w celu znalezienia współrzędnej x krawędzi dalszej
    for p in possibles:  # przeszukiwanie wszystkich otrzymanych 1 w celu znalezienia kombinacji
        check1 = siatka[p[0], p[1], p[2]:p[2] + N]
        check2 = siatka[p[0], p[1] - 1:p[1] + 1, p[2]]
        check3 = siatka[p[0], p[1]:p[1] + 2, p[2]]
        if p[0] == a[-1] and np.all(check1 == searchval) and np.all(
                check2 == searchval2):  # współrzędna x krawędzi dalszej
            punktOgraniczenia.insert(0, p) #insert żeby zawsze na początek wrzucał
        elif p[0] == a[-1] and np.all(check1 == searchval) and np.all(check3 == searchval):
            punktOgraniczenia.append(p)
    return punktOgraniczenia


gridPodstawowy = np.array([

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],

    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],


])
grid = gridPodstawowy.copy()
#
# fig = plt.figure(figsize=(12, 12))
#
# ax = fig.add_subplot(111, projection='3d')
# ax.set_xlim(0,7)
# ax.set_ylim(0,13)
# ax.set_zlim(0,16)
# # ax.scatter3D(goal[0], goal[1], goal[2], marker="*", color="red", s=100)
# for punkt, wartosc in np.ndenumerate(grid):
#  # print('wartosc'+ str(int(wartosc)) + 'punkt = ('+ str(int(punkt[0])) + ','+ str(int(punkt[1])) + ','+ str(punkt[2])+ ')')
#  if wartosc == 1:
#   ax.scatter3D(int(punkt[0]), int(punkt[1]), int(punkt[2]), marker="o", color="black", s=100)
#  # elif wartosc == 0:
#  #  ax.scatter3D(int(punkt[0]), int(punkt[1]), int(punkt[2]), marker="x", color="green", s=100)
# plt.show()

start = (14, 0, 2)

goal = (14, 12, 2)


##############################################################################

# heuristic function for path scoring

##############################################################################


def heuristic(a, b):
    return np.sqrt((b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2 + (b[2] - a[2]) ** 2)


##############################################################################

# path finding function

##############################################################################


def astar(array, start, goal):
    neighbors = [(0, 0, -1), (0, 1, -1), (1, 1, -1), (1, 0, -1), (1, -1, -1), (0, -1, -1), (-1, -1, -1), (-1, 0, -1),
                 (0, 1, 0), (1, 1, 0), (1, 0, 0), (1, -1, 0), (0, -1, 0), (-1, -1, 0), (-1, 0, 0),
                 (0, 0, 1), (0, 1, 1), (1, 1, 1), (1, 0, 1), (1, -1, 1), (0, -1, 1), (-1, -1, 1), (-1, 0, 1)]

    close_set = set()

    came_from = {}

    gscore = {start: 0}

    fscore = {start: heuristic(start, goal)}

    oheap = []

    heapq.heappush(oheap, (fscore[start], start))

    while oheap:

        current = heapq.heappop(oheap)[1]

        if current == goal:

            data = []

            while current in came_from:
                data.append(current)

                current = came_from[current]

            return data

        close_set.add(current)

        for x, y, z in neighbors:

            neighbor = current[0] + x, current[1] + y, current[2] + z #sprawdzamy po kolei każdego sąsiada

            tentative_g_score = gscore[current] + heuristic(current, neighbor) #liczenie T

            qModel = myVirtualRobotArm.inverseKinematics(neighbor[0], neighbor[1], neighbor[2])
            myVirtualRobotArm.updateJointAngles(qModel[0], qModel[1], qModel[2])
            if myVirtualRobotArm.funkcjaOgraniczen(Ograniczenia) == 1:
                continue
            if 8 <= neighbor[0] < array.shape[0]: #sprawdzanie czy w osi x sąsiad się mieści

                if 0 <= neighbor[1] < array.shape[1]: #sprawdzanie czy w osi y sąsiad się mieści

                    if 0 <= neighbor[2] < array.shape[2]: #sprawdzanie czy w osi z sąsiad się mieści

                        if array[neighbor[0]][neighbor[1]][neighbor[2]] == 1: #sprawdzanie czy sąsiad nie jest barierą
                            continue #continue oznacza przejscie od razu do kolejnej pętli
                    else:

                     # array bound z walls

                     continue

                else:

                    # array bound y walls

                    continue

            else:

                # array bound x walls

                continue

            if neighbor in close_set and tentative_g_score >= gscore.get(neighbor, 0):
                continue #jeśli sąsiad jest w zbiorze zamkniętym i jego punkty są większe bądź równe poprzednim to przejsc do
                #kolejnej petli

            if tentative_g_score < gscore.get(neighbor, 0) or neighbor not in [i[1] for i in oheap]:
                came_from[neighbor] = current

                gscore[neighbor] = tentative_g_score

                fscore[neighbor] = tentative_g_score + heuristic(neighbor, goal)

                heapq.heappush(oheap, (fscore[neighbor], neighbor))

    return False
liczbaIteracji = 0
znaleziono = False

myVirtualRobotArm = EEZYbotARM_Mk1(
        initial_q1=0, initial_q2=90, initial_q3=-90)
grid = dodajOgraniczeniaX(grid)
grid = dodajOgraniczeniaY(grid)
Ograniczenia = wyszukajSkrajne(grid)
# while(znaleziono == False):

route = astar(grid, start, goal)

route = route + [start]

route = route[::-1]


#     myVirtualRobotArm = EEZYbotARM_Mk1(
#         initial_q1=0, initial_q2=90, initial_q3=-90)
#     znaleziono = True
#     print(route)
#     for value in route:
#         qModel = myVirtualRobotArm.inverseKinematics(value[0], value[1], value[2])
#         myVirtualRobotArm.updateJointAngles(qModel[0], qModel[1], qModel[2])
#         if myVirtualRobotArm.funkcjaOgraniczen(Ograniczenia) == 1:
#             znaleziono = False
#             grid = dodajOgraniczenia(grid)
#             liczbaIteracji = liczbaIteracji + 1
#             break
# print(grid[2])
# print("liczba iteracji:" + str(liczbaIteracji))
##############################################################################

# plot the path

##############################################################################


# extract x and y coordinates from route list

x_coords = []

y_coords = []

z_coords = []

for i in (range(0, len(route))):

    x = route[i][0]

    y = route[i][1]

    z = route[i][2]

    x_coords.append(x)

    y_coords.append(y)

    z_coords.append(z)

x_coords = np.array(x_coords)

y_coords = np.array(y_coords)

z_coords = np.array(z_coords)

# plot map and path

fig, ax = plt.subplots(figsize=(12, 12))

# ax.imshow(grid, cmap=plt.cm.Dark2)
ax = fig.add_subplot(111, projection='3d')

ax.scatter3D(goal[0], goal[1], goal[2], marker="*", color="red", s=100)

for punkt, wartosc in np.ndenumerate(gridPodstawowy):
 # print('wartosc'+ str(int(wartosc)) + 'punkt = ('+ str(int(punkt[0])) + ','+ str(int(punkt[1])) + ','+ str(punkt[2])+ ')')
 if wartosc == 1:
    ax.scatter3D(int(punkt[0]), int(punkt[1]), int(punkt[2]), marker="o", color="blue", s=100)

ax.plot3D(x_coords, y_coords, z_coords, color="pink")
print('x_coords: ' + str(x_coords) + ' y_cords:' + str(y_coords) + ' z_coords:' + str(z_coords))

plt.show()
#
#
# y_coords +=13
# print(y_coords)
# x_coords -=5
#
# y_coords = y_coords*10
# x_coords = x_coords*10
# z_coords = z_coords*10
# print(x_coords)
# print(y_coords)
# print(z_coords)
#
#
# myVirtualRobotArm = EEZYbotARM_Mk1(
#     initial_q1=0, initial_q2=90, initial_q3=-90)
#
# # Define end effector open and closed angle
# servoAngle_EE_closed = 10
# servoAngle_EE_open = 180
# q=[]
# # Compute inverse kinematics
# for index,value in enumerate(z_coords):
#     qModel=myVirtualRobotArm.inverseKinematics(y_coords[index], x_coords[index], z_coords[index])
#     myVirtualRobotArm.updateJointAngles(qModel[0],qModel[1],qModel[2])
#     q.append(myVirtualRobotArm.map_kinematicsToServoAngles())
# print(q)
# ser1 = serial.Serial('COM6', baudrate=9600, timeout=1)
# time.sleep(3)
# for index in range(0,len(q)):
#     wiadomoscFB = '<'+'F,'+ str(int(q[index][1]))+'>'
#     wiadomoscUD = '<' + 'U,' + str(int(q[index][2])) + '>'
#     wiadomoscRo = '<' + 'R,' + str(int(q[index][0])) + '>'
#     wiadomoscGr = '<' + 'G,' + str(int(servoAngle_EE_open)) + '>'
#     # print(type(wiadomosc))
#     # print(wiadomosc)
#     ser1.write(bytes(wiadomoscFB, 'utf-8'))
#     ser1.write(bytes(wiadomoscUD, 'utf-8'))
#     ser1.write(bytes(wiadomoscRo, 'utf-8'))
#     ser1.write(bytes(wiadomoscGr, 'utf-8'))


